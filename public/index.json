
[{"content":"","date":"16 February 2024","externalUrl":null,"permalink":"/blogs/","section":"Blogs","summary":"","title":"Blogs","type":"blogs"},{"content":"Welcome to the world of computers! Have you ever wondered how these amazing machines actually work? Well, one of the key things to understand is something called Binary. It might sound complicated, but don’t worry, we’ll break it down for you.\nBinary is like a secret language that computers use to communicate with each other and perform tasks. It’s made up of just two digits: 0 and 1. Seems simple, right? But these two digits are incredibly powerful because they form the foundation of everything computers do.\nIn this blog, we’re going to explore how computers work using binary. We’ll start by looking at different ways numbers can be written, known as numeral systems. Then, we’ll dive into why computers specifically use binary and how they use it to represent numbers, letters, emojis, and even pictures. So, get ready to unlock the mysteries of binary and discover the inner workings of computers!\nNumeral Systems # Alright, let’s talk about how we write numbers. You might be used to seeing numbers written in a certain way, like 1, 2, 3, and so on. But did you know there are different ways to write numbers? These different ways are called numeral systems.\nThink of numeral systems like different languages for numbers. Just like people from different countries speak different languages, computers can understand different numeral systems.\nHere are some of the main numeral systems:\nUnary # Imagine counting on your fingers, where each finger represents one unit. Unary is like that, but instead of fingers, we use a single symbol, typically “1”, to represent each unit. While it might seem straightforward, unary can get cumbersome for large numbers. For example, representing the number 5 would require writing “11111”, which can quickly become impractical.\nDecimal # Decimal is the system we use in our everyday lives. It’s based on the number 10, and it uses ten symbols from 0 to 9. Each position in a decimal number represents a power of 10. For example, in the number 365, the “3” represents 3 hundreds, the “6” represents 6 tens, and the “5” represents 5 ones. Decimal is intuitive for humans because we have ten fingers, but it’s not the most efficient system for computers.\nBinary # Binary is the language of computers. It only uses two symbols: 0 and 1. This might seem limited compared to decimal, but it’s incredibly powerful for electronic devices because it’s easy to represent with switches that can be either on (1) or off (0). In binary, each position represents a power of 2. For example, the binary number 1010 represents 1 eight, 0 fours, 1 two, and 0 ones, which equals 10 in decimal.\nOctal # Octal is based on the number 8, so it uses eight symbols from 0 to 7. Octal numbers are often used to represent groups of three binary digits, making it easier to read and write binary numbers in a more compact form.\nHexadecimal # Hexadecimal is based on the number 16, so it uses sixteen symbols: 0–9 and then A–F. Hexadecimal is widely used in computing because it’s a convenient way to represent binary numbers in a more compact form. Each hexadecimal digit corresponds to four binary digits, making it easier for humans to work with large binary numbers. For example, the binary number 11011001 can be represented as D9 in hexadecimal.\nWhy Computers Use Binary? # Ever wondered why computers speak in binary, using just 0s and 1s? Well, let’s break it down.\nImagine you’re building a machine that can do calculations and make decisions. You need a way for this machine to communicate internally. Binary is the perfect choice because it’s simple and works well with the electronic components inside computers.\nComputers are made up of tiny switches called transistors. These switches can be either on or off, represented by 1 for on and 0 for off. With just these two states, we can represent all kinds of information and instructions.\nAnother reason for using binary is its reliability. With just two states, it’s easier to distinguish between different signals, reducing the chances of errors.\nAdditionally, binary aligns perfectly with the logic gates that form the building blocks of computer circuits. These gates perform operations like AND, OR, and NOT, which are the foundation of computer processing. Binary simplifies these operations, making them faster and more efficient.\nHow Computers Use Binary to Represent Numbers? # Now that we understand why computers love binary, let’s explore how they use it to represent numbers. Remember, in binary, we only have two digits: 0 and 1. But with just these two digits, computers can work wonders!\nImagine you have a row of switches, each switch representing a digit in a binary number. When a switch is on, it represents a “1”, and when it’s off, it represents a “0”. So, if we have four switches like this, we can represent numbers from 0 to 15:\n0000 (0 in decimal) 0001 (1 in decimal) 0010 (2 in decimal) 0011 (3 in decimal) and so on, up to 1111 (15 in decimal) Each switch in this row represents a power of 2. The first switch represents 2⁰ (which is 1), the second switch represents 2¹ (which is 2), the third switch represents 2² (which is 4), and so on.\nWhen we turn on or off these switches, we can represent any number using binary. For example, if we turn on the first and third switches (which represent 1 and 4 respectively), we get 0101, which is 5 in decimal.\nInside a computer’s memory, there are millions of these tiny switches working together to represent numbers. When you type a number on your keyboard, the computer converts it into binary and stores it in its memory using these switches. Then, when you ask the computer to do some math, it reads these binary numbers, performs the calculations using its electronic circuits, and gives you the answer in binary, which is then converted back to decimal for you to understand.\nHow Computers Use Binary to Represent Characters and Emojis? # Just like how computers use binary to represent numbers, they also use it to represent characters and emojis. But how does binary code turn into letters, symbols, and smiley faces?\nInside a computer’s memory, each character or emoji is assigned a unique number. This number is then represented in binary form using a specific coding scheme, such as ASCII or Unicode.\nLet’s take ASCII as an example. In ASCII (which stands for American Standard Code for Information Interchange), each character — like letters, numbers, punctuation marks, and control characters — has a corresponding numeric value.\nFor instance, the letter ‘A’ is represented by the number 65 in decimal. In binary, this is 01000001. Similarly, the number 33 in decimal corresponds to the exclamation mark ‘!’ in ASCII, which in binary is 00100001.\nSo, when you type the letter ‘A’ on your keyboard, the computer translates it into binary using the ASCII code (or another coding scheme), and then stores it in its memory using binary.\nEmojis work in a similar way. Unicode, a more modern coding standard, assigns unique numbers to characters and symbols from all languages and cultures, including emojis. For example, the emoji with the smiling face “😀” has a Unicode number associated with it, and this number is represented in binary in the computer’s memory.\nWhen you send an emoji in a text message or use it in a document, the computer converts it into binary using the Unicode encoding, and then stores and displays it accordingly.\nHow Computers Use Binary to Represent Images? # Have you ever wondered how your computer displays images on the screen? It’s all thanks to binary magic! Let’s see how it works.\nImages are made up of tiny dots called pixels. Each pixel can be a different color, and computers use binary to represent these colors.\nIn a typical image file, like a JPEG or PNG, each pixel’s color is represented by a combination of numbers that stand for its red, green, and blue components. These numbers are usually in the range of 0 to 255, where 0 represents no color (black) and 255 represents the maximum intensity of that color (white).\nNow, let’s break it down further. Each color component (red, green, and blue) is represented by 8 bits in binary. This means there are 256 possible shades for each color (2⁸ = 256).\nFor example, let’s say we have a pixel with the color red. In binary, this might be represented as 11111111 (8 bits all set to 1), indicating the maximum intensity of red. A pixel with no red at all might be represented as 00000000 (8 bits all set to 0), indicating no red.\nSimilarly, green and blue components of each pixel are represented in binary as well. So, combining these three binary numbers for each pixel gives us the full color of that pixel.\nWhen your computer displays an image, it reads these binary numbers from the image file and then converts them into colors that your screen can show. It does this millions of times for each pixel in the image, creating the beautiful pictures you see on your screen.\n","date":"16 February 2024","externalUrl":null,"permalink":"/blogs/cracking-the-binary-code/","section":"Blogs","summary":"Welcome to the world of computers!","title":"Cracking Binary: How Computers Work with 0s and 1s","type":"blogs"},{"content":"","date":"16 February 2024","externalUrl":null,"permalink":"/","section":"Sc0rpX","summary":"","title":"Sc0rpX","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":" Challenge description # The challenge provided two files:\nBinary.txt - A file containing binary-encoded data. Encode.py - A Python script that encodes text into binary based on a specific formula. Analyzing the Encode.py File # The Encode.py script contains two functions:\nx(y, z, w):\nThis function takes a string y, two integers z and w as input. Then the function multiplies the ASCII value of each character in the string y by a fixed number and converts the result into binary using bin(p)[2:].\nThe fixed number is (z + w) = 69 + 67 = 136. Example: If the character is A (ASCII value 65), the script calculates 65 * 136 = 8840 and converts it to binary: 10001010001000. n():\nThis function takes the flag, encodes it into binary using the function x(y, z, w), and prints the result.\nWriting the Decoding Script # Using the reverse logic, I wrote a decoding script:\n# Decoding the binary data def decode(binary_data, z, w): decoded_text = \u0026#34;\u0026#34; for binary_value in binary_data.split(): # Convert binary to decimal decimal_value = int(binary_value, 2) # Reverse the encoding formula to get the ASCII value ascii_value = decimal_value // (z + w) # Convert ASCII value to character decoded_text += chr(ascii_value) return decoded_text # Input from Binary.txt binary_data = \u0026#34;\u0026#34;\u0026#34;10110000011000 10100011101000 10101010000000 100000101011000 10010100110000 1101000001000 11001110001000 11011010111000 11001001111000 10010100110000 10100111111000 10101110010000 11001001111000 1001010011000 10100001100000 1100110000000 11111010110000 11010110101000 100001001101000\u0026#34;\u0026#34;\u0026#34; # Constants from Encode.py z = 69 w = 67 # Decoding the binary data flag = decode(binary_data, z, w) print(\u0026#34;Flag:\u0026#34;, flag) If you’re a noob like me, then you can also use ChatGPT to write this script.\nAfter running the script, it decoded the binary data and revealed the flag:\nFlag: SMP{F1ag_FOR_#L0ve}\n","externalUrl":null,"permalink":"/write-ups/ctfs/crypto/binarysecret/","section":"Write-ups","summary":"Challenge description # The challenge provided two files:","title":"Binary Secret","type":"write-ups"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/write-ups/ctfs/crypto/","section":"Write-ups","summary":"","title":"Crypto","type":"write-ups"},{"content":"","externalUrl":null,"permalink":"/write-ups/ctfs/","section":"Write-ups","summary":"Solutions to CTF challenges I’ve solved","title":"CTF","type":"write-ups"},{"content":"Hey there! 👋 I’m Md Mahfuzur Rahman Safin, a tech enthusiast from Bangladesh, passionate about web security and penetration testing.\n🔍 I’m on a mission to enhance my skills and take on exciting projects that challenge me to grow.\n🎯 Right now, I’m sharpening my expertise with hands-on challenges on TryHackMe 🚩 and exploring innovative ways to solve complex problems.\n🌟 The ever-evolving world of cybersecurity keeps me inspired, and I’m eager to stay ahead in this dynamic field.\nExplore My Work # 📘 Blogs: Insights into what I’m learning about cybersecurity and technology.\n✍️ Write-ups: Detailed explanations of challenges and solutions I’ve tackled.\nContact Me # 📧 Email: mahfuzurrahman5609@gmail.com\n💬 Always happy to connect—let’s discuss ideas, opportunities, or cybersecurity in general! \u0026quot;\u0026quot;\u0026quot;\n","externalUrl":null,"permalink":"/whoami/","section":"Executing: whoami","summary":"Hey there!","title":"Executing: whoami","type":"whoami"},{"content":"A collection of moments captured through the lens of my smartphone.\n","externalUrl":null,"permalink":"/shuttershell/","section":"Lens Logs","summary":"A collection of moments captured through the lens of my smartphone.","title":"Lens Logs","type":"shuttershell"},{"content":" Challenge Description # The challenge provided a website URL and the hint:\n\u0026ldquo;Test your eyes. By the way, PHP is the best programming language.\u0026rdquo;\nWhen I visited the site, it displayed a heading: \u0026ldquo;PHP VS JS\u0026rdquo; with a sliding background effect, but I couldn’t find any obvious clues or useful information.\nEnumeration # I started by viewing the source code of the site and inspecting it. The HTML file only contained an \u0026lt;h1\u0026gt; tag, and the CSS file had styling for the hover effect. Both files were simple, with no useful information or hidden clues.\nNext, I inspected the requests and responses of the site using Burp Suite. In the response headers, I noticed a line that said:\nX-Powered-By: PHP/8.1.0-dev.\nThis caught my attention because the server’s PHP version seemed suspicious.\nExploit # I searched online for \u0026ldquo;PHP/8.1.0-dev exploit\u0026rdquo; and found a known vulnerability listed on Exploit-DB.\nThe exploit provided a script to take advantage of this specific PHP version. I downloaded the script, ran it in VS Code, and gained an interactive shell to the server.\nOnce I had access to the server through the shell, I ran the command find / -name *txt to locate any text files.\nThis revealed a file named /root/flag.txt. Using the cat command, I viewed the content of the file and successfully retrieved the flag.\nFinal Flag # SMP{f0d3e7be53fd70405c9b03817b6d2a1e}\n","externalUrl":null,"permalink":"/write-ups/ctfs/web/look/","section":"Write-ups","summary":"Challenge Description # The challenge provided a website URL and the hint:","title":"LooK!","type":"write-ups"},{"content":" Challenge description # We were given a website URL and a hint in the description:\n\u0026ldquo;Basic Injection\u0026hellip; No need to bruteforce the site. No tools needed.\u0026rdquo;\nLet’s visit the website: # The website had a search input field. When I searched for a random name, it showed this message:\nTesting for Vulnerabilities # Since the challenge mentioned basic injection, I decided to test if the input field was vulnerable to injections.\nFirst, I entered a single quote (') in the input field. The response was:\u0026ldquo;Invalid Xpath payload!\u0026rdquo; This error revealed that the site was likely vulnerable to XPath Injection. XPath is used to query XML data, and improper input handling can lead to exploitation.\nI searched XPath Injection on Google to understand how it works. I learned that by using specially crafted inputs, we can bypass the query logic and trick the system into returning sensitive information.\nBased on my research, I tried the payload:\n\u0026#39; or \u0026#39;1\u0026#39;=\u0026#39;1 ' or '1'='1 is a condition that always evaluates to true, bypassing the logic of the query. I entered the payload into the input field and clicked the search button. This time, instead of the \u0026ldquo;You are not famous enough\u0026rdquo; message, it displayed the flag!\nFinal Flag # The flag for the challenge was revealed as:\nSMP{f3924191bfd367fbaf57b165e526b03f}\n","externalUrl":null,"permalink":"/write-ups/ctfs/web/pathy/","section":"Write-ups","summary":"Challenge description # We were given a website URL and a hint in the description:","title":"Pathy","type":"write-ups"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/smp-ctf-24/","section":"Tags","summary":"","title":"SMP CTF 24","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/write-ups/ctfs/web/","section":"Write-ups","summary":"","title":"Web","type":"write-ups"},{"content":"","externalUrl":null,"permalink":"/write-ups/","section":"Write-ups","summary":"","title":"Write-ups","type":"write-ups"}]